<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Prototype</title>
  </head>
  <body>
    <header>
      <h1>
        <code>Prototype</code>
    </header>
    <a href="../ejercicios/">Go Back</a>
    <p><em>Abre la consola</em></p>

    <script>
      // En Javascript todo son objetos, no tenemos clases, no tenemos ese plano para crear objetos.
      // Todos los objetos “heredan” de un prototipo que a su vez hereda de otro prototipo y así sucesivamente creando lo que se llama la prototype chain.

      //===== Un Objeto comoun y corriente

      // const zelda = {
      //   name: "Zelda",
      // };

      // zelda.saludar = function () {
      //   console.log(`Hola, soy ${this.name}`);
      // };
      // zelda.saludar();

      //==== OTRO objeto más

      // const link = {
      //   name: "Link",
      // };
      // link.saludar = function () {
      //   console.log(`Hola soy ${this.name}`);
      // };
      // link.saludar();

      //======== Seamos mas eficientes

      // function Hero(name) {
      //   const hero = {
      //     name: name,
      //   };

      //   hero.saludar = function () {
      //     console.log(`Hola, soy ${this.name}`);
      //   };

      //   return hero;
      // }
      // const zelda = Hero("Zelda");
      // zelda.saludar();
      // const link = Hero("Link");
      // link.saludar();

      //===========|      Aun podemos mejorar mas y evitar tener que crear la misma funcion cada vez que llamamos a Hero
      /*
      Creamos un objeto que contenga todos los metodos para Hero
      */
      // const heroMethods = {
      //   saludar: function () {
      //     console.log(`Hola, soy ${this.name}`);
      //   },
      // };

      // function Hero(name) {
      //   const hero = {
      //     name: name,
      //   };

      //   hero.saludar = heroMethods.saludar;

      //   return hero;
      // }
      // const zelda = Hero("Zelda");
      // zelda.saludar();
      // const link = Hero("Link");
      // link.saludar();

      //============|   Object.create

      // const nuevoObjeto = Object.create(objeto);

      // const heroMethods = {
      //   saludar: function () {
      //     console.log(`Hola, soy ${this.name}`);
      //   },
      // };

      // function Hero(name) {
      //   const hero = Object.create(heroMethods); // ESto quiere decir que todas las propiedades de heroMethos Ahora son parte de hero
      //   hero.name = name;

      //   return hero;
      // }
      // const zelda = Hero("Zelda");
      // zelda.saludar();
      // const link = Hero("Link");
      // link.saludar();

      //==============|  Los metodos de hero dentro de Hero

      // function Hero(name) {
      //   const hero = Object.create(Hero.prototype);
      //   hero.name = name;

      //   return hero;
      // }

      // Hero.prototype.saludar = function () {
      //   console.log(`New: ${this.name}`);
      // };
      // const zelda = Hero("Zelda");
      // zelda.saludar();
      // const link = Hero("Link");
      // link.saludar();

      //==============|      new es un atajo(Azucar sntactica) para llevar hero.prototype al objeto
      /*
      La keyword new crea un nuevo objeto que “hereda” todas las propiedades del prototype de otro objeto. 
      No confundir prototype con proto que es sólo una propiedad en cada instancía que apunta al prototipo
      del que hereda.
      */
      function Hero(name) {
        this.name = name;
      }

      Hero.prototype.saludar = function () {
        console.log(`New: ${this.name}`);
      };
      const zelda = new Hero("Zelda");
      zelda.saludar();
      const link = new Hero("Link");
      link.saludar();
    </script>
  </body>
</html>
